package com.fr.bi.cal.analyze.cal.index.loader;import com.finebi.cube.conf.table.BIBusinessTable;import com.finebi.cube.conf.table.BusinessTable;import com.finebi.cube.relation.BITableSourceRelation;import com.fr.bi.cal.analyze.cal.result.NodeExpander;import com.fr.bi.cal.analyze.cal.sssecret.NoneDimensionGroup;import com.fr.bi.cal.analyze.cal.sssecret.RootDimensionGroup;import com.fr.bi.cal.analyze.cal.sssecret.TreeNoneDimensionGroup;import com.fr.bi.cal.analyze.cal.sssecret.TreeRootDimensionGroup;import com.fr.bi.cal.analyze.cal.sssecret.sort.SortedRootDimensionGroup;import com.fr.bi.cal.analyze.cal.sssecret.sort.SortedTree;import com.fr.bi.cal.analyze.cal.store.GroupKey;import com.fr.bi.cal.analyze.report.report.widget.BISummaryWidget;import com.fr.bi.cal.analyze.session.BISession;import com.fr.bi.conf.report.widget.field.dimension.BIDimension;import com.fr.bi.field.target.target.BISummaryTarget;import com.fr.bi.stable.gvi.GVIFactory;import com.fr.bi.stable.gvi.GroupValueIndex;import com.fr.bi.stable.report.result.DimensionCalculator;import com.fr.bi.stable.report.result.LightNode;import com.fr.general.ComparatorUtils;import java.util.ArrayList;import java.util.List;/** * Created by Hiram on 2015/1/7. */public class MergerInfo {    public static GroupValueIndex ALL_SHOW = GVIFactory.createAllShowIndexGVI(1);    public static GroupValueIndex ALL_EMPTY = GVIFactory.createAllEmptyIndexGVI();    BISession session;    BISummaryTarget biDimensionTarget;    GroupValueIndex gvi;    RootDimensionGroup rootDimensionGroup;    NoneDimensionGroup root;    List<TargetAndKey> summaryList;    BIDimension[] biDimensions;    BusinessTable target;    private BISummaryWidget widget;    private GroupValueIndex filterIndex;    private NodeExpander expander;    private boolean needSummary;    private SortedTree sortedTree;    private LightNode tree;    public GroupKey getGroupKey() {        return groupKey;    }    private GroupKey groupKey;    private boolean hasTraverseResultFilter = false;    MergerInfo() {    }    MergerInfo(BISummaryTarget biDimensionTarget, GroupValueIndex gvi, RootDimensionGroup rootDimensionGroup, NoneDimensionGroup root, BusinessTable target, List<TargetAndKey> summaryList, BISession session, BIDimension[] biDimensions, NodeExpander expander, BISummaryWidget widget, GroupKey groupKey) {        this.biDimensionTarget = biDimensionTarget;        this.gvi = gvi;        this.rootDimensionGroup = rootDimensionGroup;        this.root = root;        this.target = target;        this.summaryList = summaryList == null ? new ArrayList<TargetAndKey>() : summaryList;        this.session = session;        this.biDimensions = biDimensions;        this.expander = expander;        this.widget = widget;        this.groupKey = groupKey;    }    public List<TargetAndKey> getTargetAndKeyList() {        return summaryList;    }    void addTargetAndKey(TargetAndKey targetAndKey){        summaryList.add(targetAndKey);    }    GroupValueIndex getGroupValueIndex() {        return gvi;    }    void setGroupValueIndex(GroupValueIndex gvi) {        this.gvi = gvi;    }    RootDimensionGroup getRootDimensionGroup() {        return rootDimensionGroup;    }    NoneDimensionGroup getRoot() {        return root;    }    void setRoot(NoneDimensionGroup root) {        this.root = root;    }    BISession getSession() {        return session;    }    void setSession(BISession session) {        this.session = session;    }    DimensionCalculator[] createColumnKey() {        DimensionCalculator[] row = new DimensionCalculator[biDimensions.length];        if (biDimensionTarget == null) {            for (int i = 0; i < row.length; i++) {                row[i] = biDimensions[i].createCalculator(biDimensions[i].getStatisticElement(), new ArrayList<BITableSourceRelation>());            }        } else {            LoaderUtils.fillRowDimension(widget, row, biDimensions, biDimensions.length, biDimensionTarget);        }        return row;    }    public boolean isNeedSummary() {        return needSummary;    }    public void setNeedSummary(boolean needSummary) {        this.needSummary = needSummary;    }    public NoneDimensionGroup createNoneDimensionGroup() {        return createNoneDimensionGroup(gvi);    }    public void applyFilterIndex(GroupValueIndex index) {        if (index == ALL_SHOW) {            return;        }        NoneDimensionGroup filterRoot = createFilterNoneDimensionGroup(index);        this.rootDimensionGroup = new RootDimensionGroup(filterRoot, createColumnKey(), biDimensions, expander, session, widget, rootDimensionGroup.isUseRealData());        gvi = gvi.AND(index);    }    public RootDimensionGroup createFinalRootDimensionGroup() {        if (hasTreeRootDimensionGroup()) {            return createTreeRootDimensionGroup();        } else {            return createIteratorRoot();        }    }    private RootDimensionGroup createIteratorRoot() {        NoneDimensionGroup filterRoot = createFilterNoneDimensionGroup();        if (sortedTree != null) {            return new SortedRootDimensionGroup(filterRoot, createColumnKey(), biDimensions, expander, session, sortedTree, widget, rootDimensionGroup.isUseRealData());        } else {            return new RootDimensionGroup(filterRoot, createColumnKey(), biDimensions, expander, session, widget, rootDimensionGroup.isUseRealData());        }    }    public NoneDimensionGroup createFilterNoneDimensionGroup() {        return createFilterNoneDimensionGroup(filterIndex);    }    private NoneDimensionGroup createFilterNoneDimensionGroup(GroupValueIndex index) {        if (index == ALL_SHOW) {            return createNoneDimensionGroup();        }        return createNoneDimensionGroup(gvi.AND(index));    }    public GroupValueIndex getFilterIndex() {        return filterIndex;    }    public void setFilterIndex(GroupValueIndex filterIndex) {        this.filterIndex = filterIndex;    }    public SortedTree getSortedTree() {        return sortedTree;    }    public void setSortedTree(SortedTree sortedTree) {        this.sortedTree = sortedTree;    }    private NoneDimensionGroup createNoneDimensionGroup(GroupValueIndex filterGetter) {        NoneDimensionGroup ng = NoneDimensionGroup.createDimensionGroup(getTableKeyWithRoot(), filterGetter, session.getLoader());        ng.setNeedAllCalculate(!ComparatorUtils.equals(ng.getTableKey(), BIBusinessTable.createEmptyTable()) && hasTraverseResultFilter);        return ng;    }    private BusinessTable getTableKeyWithRoot() {        return ComparatorUtils.equals(root.getTableKey(), BIBusinessTable.createEmptyTable()) ? root.getTableKey() : target;    }    public boolean hasTreeRootDimensionGroup() {        return tree != null;    }    public void setTreeNode(LightNode tree) {        this.tree = tree;    }    public TreeRootDimensionGroup createTreeRootDimensionGroup() {        TreeNoneDimensionGroup treeRoot = new TreeNoneDimensionGroup(tree);        return new TreeRootDimensionGroup(treeRoot, createColumnKey(), biDimensions, expander, session, widget, rootDimensionGroup.isUseRealData());    }    public void setHasTraverseResultFilter(boolean hasTraverseResultFilter) {        this.hasTraverseResultFilter = hasTraverseResultFilter;        if(this.root != null){            root.setNeedAllCalculate(hasTraverseResultFilter);        }    }}